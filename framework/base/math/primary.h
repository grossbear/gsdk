////////////////////////////////////////////////////////////////////////////////
// primary.h
//
// Math primary functions declaration
////////////////////////////////////////////////////////////////////////////////

#ifndef __PRIMARYFUNC_H__
#define __PRIMARYFUNC_H__

#include "mtypes.h"

///////////////////////////////////////////////////////////////////////////////
// Functions declaration
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Converting 32-bit integer to float
float   mitof(int32t i);
///////////////////////////////////////////////////////////////////////////////
// Converting float to 32-bit integer
int32t  mftoi(float f);

///////////////////////////////////////////////////////////////////////////////
// Converting 64-bit integer to double
///////////////////////////////////////////////////////////////////////////////
double  mitod(int64t i);
///////////////////////////////////////////////////////////////////////////////
// Converitng double to 64-bit integer
int64t  mdtoi(double d);

///////////////////////////////////////////////////////////////////////////////
// Making float number
float   mmakef(int32t sign, int32t exp, int32t mantissa);
///////////////////////////////////////////////////////////////////////////////
// Splitting float number
void    msplitf(float f, int32t &sign, int32t &exp, int32t &mant);

///////////////////////////////////////////////////////////////////////////////
// Making double number
double  mmaked(int64t sign, int64t exp, int64t mantissa);
///////////////////////////////////////////////////////////////////////////////
// Splitting double number
void    msplitd(double d, int64t &sign, int64t &exp, int64t &mant);

///////////////////////////////////////////////////////////////////////////////
// Checking if value is not a number
int32t  misnan(float f);
///////////////////////////////////////////////////////////////////////////////
int64t  misnan(double d);

///////////////////////////////////////////////////////////////////////////////
// Check if value is signaling NaN
int32t  msnan(float f);
///////////////////////////////////////////////////////////////////////////////
int64t  msnan(double d);

///////////////////////////////////////////////////////////////////////////////
// Check if value is quiet NaN
int32t  mqnan(float f);
///////////////////////////////////////////////////////////////////////////////
int64t  mqnan(double d);

///////////////////////////////////////////////////////////////////////////////
// Check if value is infinity
int32t  misinf(float f);
///////////////////////////////////////////////////////////////////////////////
int64t  misinf(double d);

///////////////////////////////////////////////////////////////////////////////
// Check if value is positive infinity
int32t  mpinf(float f);
///////////////////////////////////////////////////////////////////////////////
int64t  mpinf(double d);

///////////////////////////////////////////////////////////////////////////////
// Check if value is negative infinity
int32t  mninf(float f);
///////////////////////////////////////////////////////////////////////////////
int64t  mninf(double d);

///////////////////////////////////////////////////////////////////////////////
// Lomont compare function
// Fast function to compare two floating point numbers
bool    mlcmp(float af, float bf, int32t max_diff);

///////////////////////////////////////////////////////////////////////////////
// Calculates the floor of a value x
float   mfloor(float x);
double  mfloor(double x);

///////////////////////////////////////////////////////////////////////////////
// Calculates the ceiling of a value x
float   mceil(float x);
double  mceil(double x);


#ifdef MATH_LONG_DOUBLE_INST
///////////////////////////////////////////////////////////////////////////////
// Calculates the floor of a value x
long double mfloor(long double x);
///////////////////////////////////////////////////////////////////////////////
// Calculates the ceiling of a value x
long double mceil(long double x);
#endif //MATH_LONG_DOUBLE_INST

#ifdef MATH_FIXED_INST
///////////////////////////////////////////////////////////////////////////////
// Calculates the floor of a value x
tfixed32 mfloor(tfixed32 x);
///////////////////////////////////////////////////////////////////////////////
// Calculates the ceiling of a value x
tfixed32   mceil(tfixed32 x);
#endif //MATH_FIXED_INST

#ifdef MATH_FIXED64_INST
///////////////////////////////////////////////////////////////////////////////
// Calculates the floor of a value x
tfixed64   mfloor(tfixed64 x);
///////////////////////////////////////////////////////////////////////////////
// Calculates the ceiling of a value x
tfixed64   mceil(tfixed64 x);
#endif //MATH_FIXED64_INST

#ifdef MATH_HALF_INST
///////////////////////////////////////////////////////////////////////////////
// Calculates the floor of a value x
thalf   mfloor(thalf h);
///////////////////////////////////////////////////////////////////////////////
// Calculates the ceiling of a value x
thalf   mceil(thalf h);
#endif //MATH_HALF_INST




///////////////////////////////////////////////////////////////////////////////
// Inline functions declaration
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Inverting number (no template)
float   minvert(float x);
///////////////////////////////////////////////////////////////////////////////
double  minvert(double x);

///////////////////////////////////////////////////////////////////////////////
// Set to zero if value is near zero (no template)
float   malign0(float x);
///////////////////////////////////////////////////////////////////////////////
double  malign0(double x);




///////////////////////////////////////////////////////////////////////////////
// Template functions declaration
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Pack values from [-1,1] to [0,1]
template <typename T>
void mpack01(marray2<T> & out, const marray2<T> & in);
///////////////////////////////////////////////////////////////////////////////
template <typename T>
void mpack01(marray3<T> & out, const marray3<T> & in);
///////////////////////////////////////////////////////////////////////////////
template <typename T>
void mpack01(marray4<T> & out, const marray4<T> & in);

///////////////////////////////////////////////////////////////////////////////
// Unpack values from [0,1] to [-1,1]
template <typename T>
void munpack01(marray2<T> & out, const marray2<T> & in);
///////////////////////////////////////////////////////////////////////////////
template <typename T>
void munpack01(marray3<T> & out, const marray3<T> & in);
///////////////////////////////////////////////////////////////////////////////
template <typename T>
void munpack01(marray4<T> & out, const marray4<T> & in);

///////////////////////////////////////////////////////////////////////////////
// Finds fraction part of number x
template <typename TReal>
TReal   mfrc(TReal x);

///////////////////////////////////////////////////////////////////////////////
// Normalizing Angle To [-PI,PI]
template <typename TReal>
TReal   mnorma(TReal rad);




///////////////////////////////////////////////////////////////////////////////
// Template inline functions declaration
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Pack values from [-1,1] to [0,1]
template <typename T>
T mpack01(T x);

///////////////////////////////////////////////////////////////////////////////
// Unpack values from [0,1] to [-1,1]
template <typename T>
T munpack01(T x);

///////////////////////////////////////////////////////////////////////////////
// Getting maximum value
template <typename T>
T mmax(T x, T y);

///////////////////////////////////////////////////////////////////////////////
// Getting minimum value
template <typename T>
T mmin(T x, T y);

///////////////////////////////////////////////////////////////////////////////
// Check if number is a primary number
template <typename T>
bool misprim(T n);

///////////////////////////////////////////////////////////////////////////////
// Absolute value functions
template <typename T>
T mabs(T i);

///////////////////////////////////////////////////////////////////////////////
// Negate value
template <typename T>
T mnegate(T i);

///////////////////////////////////////////////////////////////////////////////
// Is value greater than 0
template <typename T>
bool mgre0(T i);

///////////////////////////////////////////////////////////////////////////////
// Is value greater or equals zero
template <typename T>
bool mgreq0(T i);

///////////////////////////////////////////////////////////////////////////////
// Is value equals zero
template <typename T>
bool mis0(T i);

///////////////////////////////////////////////////////////////////////////////
// Is value is less or equals zero
template <typename T>
bool mlesseq0(T i);

///////////////////////////////////////////////////////////////////////////////
// Is value less than 0
template <typename T>
bool mless0(T i);

///////////////////////////////////////////////////////////////////////////////
// Clamp Float Value To 0
template <typename T>
T mclamp0(T i);

///////////////////////////////////////////////////////////////////////////////
// Clamp value to 1
template <typename T>
T mclamp1(T i);

///////////////////////////////////////////////////////////////////////////////
// Clamp value to [0,1]
template <typename T>
T mclamp01(T i);

///////////////////////////////////////////////////////////////////////////////
// Template function clamping value between min and max values
template <typename T>
T mclamp(const T & min, const T & max, const T & val);

///////////////////////////////////////////////////////////////////////////////
// Is number is power of 2
template <typename T>
bool mispow2(T n);

///////////////////////////////////////////////////////////////////////////////
// Sgn
template <typename T>
T msgn(T x);




///////////////////////////////////////////////////////////////////////////////
// Inline template functions definition
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Pack values from [-1,1] to [0,1]
template <typename T>
inline T mpack01(T x)
{
    static const T half_val(0.5);
    return x * half_val + half_val;
}

///////////////////////////////////////////////////////////////////////////////
// Unpack values from [0,1] to [-1,1]
template <typename T>
inline T munpack01(T x)
{
    static const T two_val(2.0);
    static const T one_val(1.0);
    return x * two_val - one_val;
}

///////////////////////////////////////////////////////////////////////////////
// Absolute value functions
template <typename T>
inline T mabs(T i)
{
    return (i >> (sizeof(T) - 1)) ? ((~i) + 1) : (i);
}

///////////////////////////////////////////////////////////////////////////////
// Negate value
template <typename T>
inline T mnegate(T i)
{
    return -i;
}

///////////////////////////////////////////////////////////////////////////////
// Is value greater than 0
template <typename T>
inline bool mgre0(T i)
{
    return i > 0;
}

///////////////////////////////////////////////////////////////////////////////
// Is value greater or equals zero
template <typename T>
inline bool mgreq0(T i)
{
    return i >= 0;
}

///////////////////////////////////////////////////////////////////////////////
// Is value equals zero
template <typename T>
inline bool mis0(T i)
{
    return i == 0;
}

///////////////////////////////////////////////////////////////////////////////
// Is value is less or equals zero
template <typename T>
inline bool mlesseq0(T i)
{
    return i <= 0;
}

///////////////////////////////////////////////////////////////////////////////
// Is value less than 0
template <typename T>
inline bool mless0(T i)
{
    return i < 0;
}

///////////////////////////////////////////////////////////////////////////////
// Clamp Float Value To 0
template <typename T>
inline T mclamp0(T i)
{
    return (i > 0) ? (0) : (i);
}

///////////////////////////////////////////////////////////////////////////////
// Clamp value to 1
template <typename T>
inline T mclamp1(T i)
{
    return (i > 1) ? (1) : (i);
}

///////////////////////////////////////////////////////////////////////////////
// Clamp value to [0,1]
template <typename T>
inline T mclamp01(T i)
{
    return (mless0(i)) ? (0) : (mclamp1(i));
}

///////////////////////////////////////////////////////////////////////////////
// Template function clamping value between min and max values
template <typename T>
inline T  mclamp(const T & min, const T & max, const T & val)
{
    return (val < min) ? (min) : ((val > max) ? max : val);
}

///////////////////////////////////////////////////////////////////////////////
// Getting Maximum Value
template <typename T>
T mmax(T x, T y)
{
    return (x > y) ? (x) : (y);
}
///////////////////////////////////////////////////////////////////////////////
// Getting Minimum Value
template <typename T>
T mmin(T x, T y)
{
    return (x < y) ? (x) : (y);
}


///////////////////////////////////////////////////////////////////////////////
// Is number is power of 2
template <typename T>
inline bool mispow2(T n)
{
    return !(n & (n - 1));
}

///////////////////////////////////////////////////////////////////////////////
// Sgn
template <typename T>
inline T msgn(T x)
{
    return (x > 0) ? (1) : ((x < 0) ? (-1) : (0));
}




///////////////////////////////////////////////////////////////////////////////
// Inline template functions specialization
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Absolute value functions
inline float  mabs(float f)
{
    return *(float*) & (*(int32t*) &f &= MATH_INT_MAX);
}
///////////////////////////////////////////////////////////////////////////////
inline double mabs(double d)
{
    return *(double*) & (*(int64t*) &d &= MATH_INT64_MAX);
}
///////////////////////////////////////////////////////////////////////////////
#ifdef  MATH_LONG_DOUBLE_INST
inline long double mabs(long double d)
{
    return (d < 0.0) ? (-d) : (d);
}
#endif
///////////////////////////////////////////////////////////////////////////////
#ifdef  MATH_FIXED_INST
inline tfixed32 mabs(tfixed32 x)
{
    return (*(int32t*)x) < 0 ? (-x) : (x);
}
#endif
///////////////////////////////////////////////////////////////////////////////
#ifdef  MATH_FIXED64_INST
inline tfixed64 mabs(tfixed64 x)
{
    return (*(int64t*)x) < 0 ? (-x) : (x);
}
#endif
///////////////////////////////////////////////////////////////////////////////
#ifdef  MATH_HALF_INST
inline thalf mabs(thalf h)
{
    return *(thalf*) & (*(uint16t*) &h &= MATH_INT16_MAX);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// Negate value
inline float  mnegate(float f)
{
    return *(float*) & (*(int32t*) &f ^= MATH_INT_MIN);
}
///////////////////////////////////////////////////////////////////////////////
inline double mnegate(double d)
{
    return *(double*) & (*(int64t*) &d ^= MATH_INT64_MIN);
}


///////////////////////////////////////////////////////////////////////////////
// Is value near zero (no template)
inline bool  mnear0(float f)
{
    return mabs(f) < FLOAT_EPS;
}
///////////////////////////////////////////////////////////////////////////////
inline bool  mnear0(double d)
{
    return mabs(d) < DOUBLE_EPS;
}

///////////////////////////////////////////////////////////////////////////////
// Is value greater than 0
inline bool mgre0(float f)
{
    return *(int32t*) &f > 0;
}
///////////////////////////////////////////////////////////////////////////////
inline bool mgre0(double d)
{
    return *(int64t*) &d > 0;
}

///////////////////////////////////////////////////////////////////////////////
// Is value greater or equals zero
inline bool mgreq0(float f)
{
    return *(uint32t*) &f <= 0x80000000UL;
}
///////////////////////////////////////////////////////////////////////////////
inline bool mgreq0(double d)
{
    return *(uint64t*) &d <= 0x8000000000000000UL;
}

///////////////////////////////////////////////////////////////////////////////
// Is value equals zero
inline bool mis0(float f)
{
    return (*(int32t*) &f & MATH_INT_MAX) == 0;
}
///////////////////////////////////////////////////////////////////////////////
inline bool mis0(double d)
{
    return (*(int64t*) &d & MATH_INT64_MAX) == 0;
}

///////////////////////////////////////////////////////////////////////////////
// Is value is less or equals zero
inline bool mlesseq0(float f)
{
    return *(int32t*) &f <= 0;
}
///////////////////////////////////////////////////////////////////////////////
inline bool mlesseq0(double d)
{
    return *(int64t*) &d <= 0;
}

///////////////////////////////////////////////////////////////////////////////
// Is value less than 0
inline bool mless0(float f)
{
    return *(int32t*) &f < 0;
}
///////////////////////////////////////////////////////////////////////////////
inline bool mless0(double d)
{
    return *(int64t*) &d < 0;
}
///////////////////////////////////////////////////////////////////////////////
#ifdef MATH_HALF_INST
inline bool mless0(thalf h)
{
    return *(uint16t*) &h & MATH_INT16_MIN;
}
#endif //MATH_HALF_INST

///////////////////////////////////////////////////////////////////////////////
// Clamp Float Value To 0
inline float mclamp0(float f)
{
    int32t s = (*(int32t*) &f) >> 31;
    s = ~s;
    *(int32t*) &f &= s;

    return f;
}
///////////////////////////////////////////////////////////////////////////////
inline double mclamp0(double d)
{
    int64t s = (*(int64t*) &d) >> 63;
    s = ~s;
    *(int64t*) &d &= s;

    return d;
}

///////////////////////////////////////////////////////////////////////////////
// Clamp value to 1
inline float mclamp1(float f)
{
    return *(int32t*) &f > 0x3f800000 ? 1.0f : f;
}
///////////////////////////////////////////////////////////////////////////////
inline double mclamp1(double d)
{
    return *(int64t*) &d > 0x3ff0000000000000 ? 1.0 : d;
}

///////////////////////////////////////////////////////////////////////////////
// Clamp value to [0,1]
inline float mclamp01(float f)
{
    if(mless0(f))
        return 0.0f;

    return mclamp1(f);
}
///////////////////////////////////////////////////////////////////////////////
inline double mclamp01(double d)
{
    if(mless0(d))
        return 0.0;

    return mclamp1(d);
}


///////////////////////////////////////////////////////////////////////////////
// Sgn
inline float msgn(float x)
{
    return (mless0(x)) ? (-1.0f) : ((mgre0(x)) ? (1.0f) : (0.0f));
}
///////////////////////////////////////////////////////////////////////////////
inline double msgn(double x)
{
    return (mless0(x)) ? (-1.0) : ((mgre0(x)) ? (1.0) : (0.0));
}




///////////////////////////////////////////////////////////////////////////////
// Inline functions definition
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Inverting number (no template)
inline float   minvert(float x)
{
    ASSERT(!mnear0(x));
    return 1.0f/x;
}
///////////////////////////////////////////////////////////////////////////////
inline double  minvert(double x)
{
    ASSERT(!mnear0(x));
    return 1.0/x;
}

///////////////////////////////////////////////////////////////////////////////
// Set to zero if value is near zero (no template)
inline float   malign0(float x)
{
    if((x > -FLOAT_EPS) && (x < FLOAT_EPS))
        return 0.0f;
    else
        return x;
}
///////////////////////////////////////////////////////////////////////////////
inline double  malign0(double x)
{
    if((x > -DOUBLE_EPS) && (x < DOUBLE_EPS))
        return 0.0;
    else
        return x;
}


#endif //__PRIMARYFUNC_H__


